{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to simple-template-toolkit","text":"<p>Simple templating for all your templating needs.</p>"},{"location":"#commands","title":"Commands","text":"<p>The following exported scripts are available:</p> <ul> <li>insert-lines</li> <li>make-substitutions</li> </ul>"},{"location":"#references","title":"References","text":"<ul> <li>GitHub</li> <li>PYPI</li> </ul>"},{"location":"CHANGELOG/","title":"Change Log","text":""},{"location":"CHANGELOG/#v012-2024-02-05","title":"v0.1.2 - 2024-02-05","text":"<p>FIXES: - Adds support for performing substitutions for placeholders in the values themselves. - Fixes support for tallying number of keys/placeholders found.</p>"},{"location":"CHANGELOG/#v010-2024-01-24","title":"v0.1.0 - 2024-01-24","text":"<p>ADDS: - Initial support for make-substitutions - Initial support for insert-lines</p>"},{"location":"INSTALL/","title":"INSTALL","text":""},{"location":"INSTALL/#clone-project","title":"Clone project","text":"<p>You can <code>git clone</code> this project.</p> <pre><code>git clone https://github.com/jai-python3/simple-template-toolkit.git\ncd simple-template-toolkit\n</code></pre>"},{"location":"INSTALL/#local-pip-install","title":"Local pip install","text":"<p>You can optionally establish a Python virtual environment. Then you can run the <code>setup.py</code> script to build to project and then run <code>pip install</code> to install in your local Python virtual environment.</p> <pre><code>virtualenv -p python3 venv\nsource venv/bin/activate\npython setup.py sdist\npip install .\n</code></pre>"},{"location":"INSTALL/#uninstall","title":"Uninstall","text":"<p>You can uninstall like this:</p> <pre><code>source venv/bin/activate\npip uninstall simple-template-toolkit\nmake clean\n</code></pre>"},{"location":"INSTALL/#developers","title":"Developers","text":"<p>If you modify the code in this package in your local virtual environment:</p> <pre><code>pip uninstall simple-template-toolkit\nmake clean\npython setup.py sdist\npip install .\n</code></pre>"},{"location":"INSTALL/#publish-to-pypi","title":"Publish to PYPI","text":"<p>You want can publish the code in this package to the PYPI repository.</p>"},{"location":"INSTALL/#install-twine-and-setuptools","title":"Install twine and setuptools","text":"<p>Install <code>twine</code> and <code>setuptools</code>.</p> <pre><code>pip install twine setuptools\n</code></pre>"},{"location":"INSTALL/#build-the-distribution-package","title":"Build the Distribution Package","text":"<pre><code>python setup.py sdist bdist_wheel\n</code></pre>"},{"location":"INSTALL/#configure-your-pypirc","title":"Configure your ~/.pypirc:","text":"<pre><code>[pypi]\n  username = __token__\n  password = pypi-YOUR-TOKEN\n</code></pre>"},{"location":"INSTALL/#upload-your-package-to-pypi","title":"Upload Your Package to PyPI","text":"<pre><code>twine upload dist/*\n</code></pre>"},{"location":"INSTALL/#install-from-pypi","title":"Install from PYPI","text":"<p>Now you can install your package in your Python virtual environment</p> <pre><code>pip install simple-template-toolkit\n</code></pre>"},{"location":"click_helper/","title":"Click Helper module","text":""},{"location":"click_helper/#simple_template_toolkit.click_helper.validate_verbose","title":"<code>validate_verbose(ctx, param, value)</code>","text":"<p>Validate the validate option.</p> <p>Parameters:</p> Name Type Description Default <code>ctx</code> <code>Context</code> <p>The click context.</p> required <code>param</code> <code>str</code> <p>The parameter.</p> required <code>value</code> <code>bool</code> <p>The value.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>The value.</p> Source code in <code>simple_template_toolkit/click_helper.py</code> <pre><code>def validate_verbose(ctx, param, value):\n    \"\"\"Validate the validate option.\n\n    Args:\n        ctx (Context): The click context.\n        param (str): The parameter.\n        value (bool): The value.\n\n    Returns:\n        bool: The value.\n    \"\"\"\n    if value is None:\n        click.secho(\"--verbose was not specified and therefore was set to 'True'\", fg='yellow')\n        return DEFAULT_VERBOSE\n    return value\n</code></pre>"},{"location":"console_helper/","title":"Console Helper module","text":"<p>Module for console helper functions.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p>"},{"location":"console_helper/#simple_template_toolkit.console_helper.print_green","title":"<code>print_green(msg=None)</code>","text":"<p>Print a message in green.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be printed in red. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p> Source code in <code>simple_template_toolkit/console_helper.py</code> <pre><code>def print_green(msg: str = None) -&gt; None:\n    \"\"\"Print a message in green.\n\n    Args:\n        msg (str, optional): The message to be printed in red. Defaults to None.\n\n    Raises:\n        Exception: If msg is not defined\n    \"\"\"\n    if msg is None or msg == \"\":\n        raise Exception(\"msg was not defined\")\n\n    console.print(f\"[bold green]{msg}[/]\")\n</code></pre>"},{"location":"console_helper/#simple_template_toolkit.console_helper.print_red","title":"<code>print_red(msg=None)</code>","text":"<p>Print a message in red.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be printed in red. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p> Source code in <code>simple_template_toolkit/console_helper.py</code> <pre><code>def print_red(msg: str = None) -&gt; None:\n    \"\"\"Print a message in red.\n\n    Args:\n        msg (str, optional): The message to be printed in red. Defaults to None.\n\n    Raises:\n        Exception: If msg is not defined\n    \"\"\"\n    if msg is None or msg == \"\":\n        raise Exception(\"msg was not defined\")\n    error_console.print(msg)\n</code></pre>"},{"location":"console_helper/#simple_template_toolkit.console_helper.print_yellow","title":"<code>print_yellow(msg=None)</code>","text":"<p>Print a message in yellow.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be printed in red. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If msg is not defined</p> Source code in <code>simple_template_toolkit/console_helper.py</code> <pre><code>def print_yellow(msg: str = None) -&gt; None:\n    \"\"\"Print a message in yellow.\n\n    Args:\n        msg (str, optional): The message to be printed in red. Defaults to None.\n\n    Raises:\n        Exception: If msg is not defined\n    \"\"\"\n    if msg is None or msg == \"\":\n        raise Exception(\"msg was not defined\")\n\n    console.print(f\"[bold yellow]{msg}[/]\")\n</code></pre>"},{"location":"constants/","title":"Constants module","text":""},{"location":"file_utils/","title":"File Utils module","text":""},{"location":"file_utils/#simple_template_toolkit.file_utils.calculate_md5","title":"<code>calculate_md5(file_path)</code>","text":"<p>Calculate the md5 checksum for the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the file for which the md5 checksum will be calculated</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the calculated md5 checksum</p> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def calculate_md5(file_path: str) -&gt; str:\n    \"\"\"Calculate the md5 checksum for the specified file.\n\n    Args:\n        file_path (str): the file for which the md5 checksum will be calculated\n\n    Returns:\n        str: the calculated md5 checksum\n    \"\"\"\n    md5_hash = hashlib.md5()\n    logging.info(f\"Will attempt to calculate the MD5 checksum for file '{file_path}'\")\n\n    with open(file_path, \"rb\") as file:\n        # Read the file in chunks to efficiently handle large files\n        for chunk in iter(lambda: file.read(4096), b\"\"):\n            md5_hash.update(chunk)\n\n    return md5_hash.hexdigest()\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.check_indir_status","title":"<code>check_indir_status(indir=None)</code>","text":"<p>Check if the directory exists and is a regular directory.</p> <p>Parameters:</p> Name Type Description Default <code>indir</code> <code>str</code> <p>the directory to be checked</p> <code>None</code> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def check_indir_status(indir: str = None) -&gt; None:\n    \"\"\"Check if the directory exists and is a regular directory.\n\n    Args:\n        indir (str): the directory to be checked\n    \"\"\"\n    error_ctr = 0\n\n    if indir is None or indir == '':\n        error_console.print(f\"'{indir}' is not defined\")\n        error_ctr += 1\n    else:\n        if not os.path.exists(indir):\n            error_ctr += 1\n            error_console.print(f\"directory '{indir}' does not exist\")\n        else:\n            if not os.path.isdir(indir):\n                error_ctr += 1\n                error_console.print(f\"'{indir}' is not a regular directory\")\n\n    if error_ctr &gt; 0:\n        error_console.print(f\"Detected problems with input directory '{indir}'\")\n        sys.exit(1)\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.check_infile_status","title":"<code>check_infile_status(infile, extension=None)</code>","text":"<p>Check if the file exists, if it is a regular file and whether it has content.</p> <p>Parameters:</p> Name Type Description Default <code>infile</code> <code>str</code> <p>the file to be checked</p> required Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def check_infile_status(infile: str, extension: Optional[str] = None) -&gt; None:\n    \"\"\"Check if the file exists, if it is a regular file and whether it has\n    content.\n\n    Args:\n        infile (str): the file to be checked\n\n    Raises:\n        None\n    \"\"\"\n\n    error_ctr = 0\n\n    if infile is None or infile == \"\":\n        error_console.print(f\"'{infile}' is not defined\")\n        error_ctr += 1\n    else:\n        if not os.path.exists(infile):\n            error_ctr += 1\n            error_console.print(f\"'{infile}' does not exist\")\n        else:\n            if not os.path.isfile(infile):\n                error_ctr += 1\n                error_console.print(f\"'{infile}' is not a regular file\")\n            if os.stat(infile).st_size == 0:\n                error_console.print(f\"'{infile}' has no content\")\n                error_ctr += 1\n            if extension is not None and not infile.endswith(extension):\n                error_console.print(\n                    f\"'{infile}' does not have filename extension '{extension}'\"\n                )\n                error_ctr += 1\n\n    if error_ctr &gt; 0:\n        error_console.print(f\"Detected problems with input file '{infile}'\")\n        sys.exit(1)\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.get_file_creation_date","title":"<code>get_file_creation_date(file_path)</code>","text":"<p>Determine the creation date for the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>the absolute path of the file</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>the date the file was created according to the operating system</p> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def get_file_creation_date(file_path: str) -&gt; datetime:\n    \"\"\"Determine the creation date for the specified file.\n\n    Args:\n        file_path (str): the absolute path of the file\n\n    Returns:\n        datetime: the date the file was created according to the operating system\n    \"\"\"\n    if platform.system() == \"Windows\":\n        # On Windows, use creation time\n        creation_time = os.path.getctime(file_path)\n    else:\n        # On Unix-based systems, use birth time (creation time)\n        # Note: Not all file systems support birth time, and it might not be available on some systems.\n        stat_info = os.stat(file_path)\n        creation_time = stat_info.st_mtime\n\n    # Convert the timestamp to a readable date\n    creation_date = datetime.fromtimestamp(creation_time)\n\n    return creation_date\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.get_file_list_from_directory","title":"<code>get_file_list_from_directory(indir=None, extension=None)</code>","text":"<p>Get the list of files in the specified directory :param indir: {str} - the directory to search for files :param extension: {str} - the file extension to filter on :returns file_list: {list} - the list of files found in the directory</p> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def get_file_list_from_directory(indir: str = None, extension: str = None) -&gt; list:\n    \"\"\"Get the list of files in the specified directory\n    :param indir: {str} - the directory to search for files\n    :param extension: {str} - the file extension to filter on\n    :returns file_list: {list} - the list of files found in the directory\n    \"\"\"\n    if extension is None:\n        logging.info(f\"Going to search for files in directory '{indir}'\")\n    else:\n        logging.info(f\"Going to search for files with extension '{extension}' in directory '{indir}'\")\n\n    file_list = []\n    for dirpath, dirnames, filenames in os.walk(indir):\n        if 'venv' in dirpath:\n            logging.info(f\"Going to ignore files in directory '{dirpath}'\")\n            continue\n        for name in filenames:\n            file_path = os.path.normpath(os.path.join(dirpath, name))\n            if os.path.isfile(file_path):\n                if extension is not None:\n                    if file_path.endswith(f'.{extension}'):\n                        file_list.append(file_path)\n                else:\n                    file_list.append(file_path)\n\n    return file_list\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.get_file_size","title":"<code>get_file_size(file_path)</code>","text":"<p>Get the size of the specified file in bytes.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be checked.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the file does not exist.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The size of the file in bytes.</p> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def get_file_size(file_path: str) -&gt; int:\n    \"\"\"Get the size of the specified file in bytes.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n\n    Raises:\n        Exception: If the file does not exist.\n\n    Returns:\n        int: The size of the file in bytes.\n    \"\"\"\n    # Check if the file exists\n    if os.path.exists(file_path):\n        # Get the file size in bytes\n        file_size = os.path.getsize(file_path)\n        return file_size\n    else:\n        raise Exception(f\"The file '{file_path}' does not exist.\")\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.get_line_count","title":"<code>get_line_count(file_path)</code>","text":"<p>Get the number of lines in the specified file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be checked.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of lines in the file.</p> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def get_line_count(file_path: str) -&gt; int:\n    \"\"\"Get the number of lines in the specified file.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n\n    Returns:\n        int: The number of lines in the file.\n    \"\"\"\n    # if is_binary_file(file_path):\n    #     print(f\"Unable to get line count for binary file '{file_path}'\")\n    #     return None\n    try:\n        with open(file_path, 'r') as file:\n            line_count = sum(1 for line in file)\n        return line_count\n    except FileNotFoundError:\n        print(f\"File '{file_path}' not found.\")\n        return None\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n</code></pre>"},{"location":"file_utils/#simple_template_toolkit.file_utils.is_binary_file","title":"<code>is_binary_file(file_path, block_size=1024)</code>","text":"<p>Check if the specified file is a binary file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to be checked.</p> required <code>block_size</code> <code>int</code> <p>The block size. Defaults to 1024.</p> <code>1024</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>If the file is binary, returns True. Otherwise, returns False.</p> Source code in <code>simple_template_toolkit/file_utils.py</code> <pre><code>def is_binary_file(file_path: str, block_size: int = 1024) -&gt; bool:\n    \"\"\"Check if the specified file is a binary file.\n\n    Args:\n        file_path (str): The path to the file to be checked.\n        block_size (int, optional): The block size. Defaults to 1024.\n\n    Returns:\n        bool: If the file is binary, returns True. Otherwise, returns False.\n    \"\"\"\n    try:\n        with open(file_path, 'rb') as file:\n            block = file.read(block_size)\n            if not block:  # Empty file\n                return False\n\n            # Check for the presence of null bytes (indicative of binary files)\n            if b'\\x00' in block:\n                return True\n\n            # Check for a significant number of non-printable ASCII characters\n            text_characters = set(string.printable)\n            if not all(byte in text_characters or byte == b'\\n' for byte in block):\n                return True\n\n            return False  # File is likely text\n\n    except FileNotFoundError:\n        print(f\"File '{file_path}' not found.\")\n        return None\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n        return None\n</code></pre>"},{"location":"insert_lines/","title":"Insert Lines module","text":"<p>Insert values into file with placeholders.</p>"},{"location":"insert_lines/#simple_template_toolkit.insert_lines.main","title":"<code>main(infile, logfile, outdir, outfile, template_file, verbose)</code>","text":"<p>Insert lines at specified anchors.</p> Source code in <code>simple_template_toolkit/insert_lines.py</code> <pre><code>@click.command()\n@click.option('--infile', type=click.Path(exists=True), help=\"Required: The input file that contains key-value pairs to drive the placeholder substitution.\")\n@click.option('--logfile', help=\"Optional: The log file.\")\n@click.option('--outdir', help=f\"Optional: The directory where the log file and output file will be written - default is '{constants.DEFAULT_OUTDIR}'.\")\n@click.option('--outfile', help=\"Optional: The output file.\")\n@click.option('--template_file', type=click.Path(exists=True), help=\"Required: The input template file that contains placeholders to be substituted.\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{constants.DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(infile: str, logfile: Optional[str], outdir: Optional[str], outfile: Optional[str], template_file: str, verbose: Optional[bool]):\n    \"\"\"Insert lines at specified anchors.\"\"\"\n    error_ctr = 0\n\n    if infile is None:\n        print_red(\"--infile was not specified\")\n        error_ctr += 1\n\n    if template_file is None:\n        print_red(\"--template_file was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    check_infile_status(template_file, \"tt\")\n    check_infile_status(infile, \"yaml\")\n\n    if outdir is None:\n        outdir = constants.DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n    logging.basicConfig(\n        filename=logfile,\n        format=constants.DEFAULT_LOGGING_FORMAT,\n        level=constants.DEFAULT_LOGGING_LEVEL,\n    )\n\n    manager = TemplateToolkitManager(\n        verbose=verbose\n    )\n\n    manager.insert_lines(\n        key_val_file=infile,\n        template_file=template_file,\n        outfile=outfile,\n    )\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"make_shell_scripts_and_aliases/","title":"Make Shell Scripts And Aliases module","text":""},{"location":"make_shell_scripts_and_aliases/#simple_template_toolkit.make_shell_scripts_and_aliases.create_aliases_file","title":"<code>create_aliases_file(wrapper_scripts, outdir, prefix=DEFAULT_ALIAS_PREFIX)</code>","text":"<p>Create a file with aliases for the wrapper scripts.</p> <p>Parameters:</p> Name Type Description Default <code>wrapper_scripts</code> <code>List[str]</code> <p>list of wrapper scripts</p> required <code>outdir</code> <code>str</code> <p>output directory</p> required Source code in <code>simple_template_toolkit/make_shell_scripts_and_aliases.py</code> <pre><code>def create_aliases_file(wrapper_scripts: List[str], outdir: str, prefix: str = DEFAULT_ALIAS_PREFIX) -&gt; None:\n    \"\"\"Create a file with aliases for the wrapper scripts.\n\n    Args:\n        wrapper_scripts (List[str]): list of wrapper scripts\n        outdir (str): output directory\n    \"\"\"\n    outfile = os.path.join(outdir, f\"{DEFAULT_PROJECT}-aliases.txt\")\n\n    with open(outfile, 'w') as of:\n        of.write(f\"## method-created: {os.path.abspath(__file__)}\\n\")\n        of.write(f\"## date-created: {str(datetime.today().strftime('%Y-%m-%d-%H%M%S'))}\\n\")\n        of.write(f\"## created-by: {os.environ.get('USER')}\\n\")\n        for wrapper_script in wrapper_scripts:\n            alias = os.path.basename(wrapper_script).replace(\".sh\", \"\")\n            line = f\"alias {prefix}-{alias}='bash {wrapper_script}'\"\n            of.write(f\"{line}\\n\")\n\n    print(f\"Wrote aliases file '{outfile}'\")\n</code></pre>"},{"location":"make_shell_scripts_and_aliases/#simple_template_toolkit.make_shell_scripts_and_aliases.main","title":"<code>main(alias_prefix)</code>","text":"<p>Create wrapper shell scripts and aliases.</p> Source code in <code>simple_template_toolkit/make_shell_scripts_and_aliases.py</code> <pre><code>@click.command()\n@click.option(\n    \"--alias-prefix\",\n    type=str,\n    help=f\"Optional: The prefix to be applied to the aliases - default is '{DEFAULT_ALIAS_PREFIX}'\",\n)\ndef main(alias_prefix: str):\n    \"\"\"Create wrapper shell scripts and aliases.\"\"\"\n    error_ctr = 0\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    if alias_prefix is None:\n        alias_prefix = DEFAULT_ALIAS_PREFIX\n        console.print(f\"[bold yellow]--alias-prefix was not specified and therefore was set to '{alias_prefix}'[/]\")\n\n    wrapper_scripts = []\n\n    # Directory where the wrapper scripts will be created\n    wrapper_scripts_dir = os.getcwd()\n    make_script_dir = os.path.dirname(__file__)\n\n    activate_script = os.path.join(\n        make_script_dir,\n        \"..\",\n        \"..\",\n        \"..\",\n        \"..\",\n        \"bin\",\n        \"activate\"\n    )\n\n    if not os.path.exists(activate_script):\n        raise Exception(f\"Activate script '{activate_script}' does not exist\")\n    print(f\"activate_script: {activate_script}\")\n\n    for executable in EXECUTABLES:\n        wrapper_script = create_wrapper_script(executable, activate_script, wrapper_scripts_dir)\n        wrapper_scripts.append(wrapper_script)\n\n    create_aliases_file(wrapper_scripts, os.getcwd(), alias_prefix)\n\n    console.print(f\"[bold green]Execution of {os.path.abspath(__file__)} completed[/]\")\n</code></pre>"},{"location":"make_substitutions/","title":"Make Substitutions module","text":"<p>Insert values into file with placeholders.</p>"},{"location":"make_substitutions/#simple_template_toolkit.make_substitutions.main","title":"<code>main(infile, logfile, outdir, outfile, template_file, verbose)</code>","text":"<p>Perform placeholder substitutions.</p> Source code in <code>simple_template_toolkit/make_substitutions.py</code> <pre><code>@click.command()\n@click.option('--infile', type=click.Path(exists=True), help=\"Required: The input file that contains key-value pairs to drive the placeholder substitution.\")\n@click.option('--logfile', help=\"Optional: The log file.\")\n@click.option('--outdir', help=f\"Optional: The directory where the log file and output file will be written - default is '{constants.DEFAULT_OUTDIR}'.\")\n@click.option('--outfile', help=\"Optional: The output file.\")\n@click.option('--template_file', type=click.Path(exists=True), help=\"Required: The input template file that contains placeholders to be substituted.\")\n@click.option('--verbose', is_flag=True, help=f\"Optional: Will print more info to STDOUT - default is '{constants.DEFAULT_VERBOSE}'.\", callback=validate_verbose)\ndef main(infile: str, logfile: Optional[str], outdir: Optional[str], outfile: Optional[str], template_file: str, verbose: Optional[bool]):\n    \"\"\"Perform placeholder substitutions.\"\"\"\n    error_ctr = 0\n\n    if infile is None:\n        print_red(\"--infile was not specified\")\n        error_ctr += 1\n\n    if template_file is None:\n        print_red(\"--template_file was not specified\")\n        error_ctr += 1\n\n    if error_ctr &gt; 0:\n        click.echo(click.get_current_context().get_help())\n        sys.exit(1)\n\n    check_infile_status(template_file, \"tt\")\n    check_infile_status(infile, \"yaml\")\n\n    if outdir is None:\n        outdir = constants.DEFAULT_OUTDIR\n        print_yellow(f\"--outdir was not specified and therefore was set to '{outdir}'\")\n\n    if not os.path.exists(outdir):\n        pathlib.Path(outdir).mkdir(parents=True, exist_ok=True)\n        print_yellow(f\"Created output directory '{outdir}'\")\n\n    if logfile is None:\n        logfile = os.path.join(\n            outdir,\n            os.path.splitext(os.path.basename(__file__))[0] + '.log'\n        )\n        print_yellow(f\"--logfile was not specified and therefore was set to '{logfile}'\")\n\n    logging.basicConfig(\n        filename=logfile,\n        format=constants.DEFAULT_LOGGING_FORMAT,\n        level=constants.DEFAULT_LOGGING_LEVEL,\n    )\n\n    manager = TemplateToolkitManager(\n        verbose=verbose\n    )\n\n    manager.make_substitutions(\n        key_val_file=infile,\n        template_file=template_file,\n        outfile=outfile,\n    )\n\n    if verbose:\n        console.print(f\"The log file is '{logfile}'\")\n        print_green(f\"Execution of '{os.path.abspath(__file__)}' completed\")\n</code></pre>"},{"location":"manager/","title":"Manager module","text":""},{"location":"manager/#simple_template_toolkit.manager.Manager","title":"<code>Manager</code>","text":"<p>Class for managing a placeholder substitutions and line insertions.</p> Source code in <code>simple_template_toolkit/manager.py</code> <pre><code>class Manager:\n    \"\"\"Class for managing a placeholder substitutions and line insertions.\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Constructor for Manager.\"\"\"\n        self.template_file = kwargs.get(\"template_file\", None)\n        self.key_val_file = kwargs.get(\"key_val_file\", None)\n        self.outdir = kwargs.get(\"outdir\", None)\n        self.outfile = kwargs.get(\"outfile\", None)\n        self.verbose = kwargs.get(\"verbose\", constants.DEFAULT_VERBOSE)\n\n        self._found_keys_lookup = {}\n        self._found_keys_ctr = 0\n\n        logging.info(f\"Instantiated Manager in file '{os.path.abspath(__file__)}'\")\n\n    def _get_lookup(self, key_val_file: str) -&gt; Dict[str, str]:\n        \"\"\"Derive the lookup from the key-value pairs YAML file.\n\n        Args:\n            key_val_file (str): The key-value pairs YAML file.\n\n        Returns:\n            Dict[str, str]: The lookup.\n        \"\"\"\n        logging.info(f\"Will load contents of key-value file '{key_val_file}'\")\n        lookup = yaml.safe_load(Path(key_val_file).read_text())\n        return lookup\n\n    def make_substitutions(self, key_val_file: Optional[str], template_file: Optional[str], outfile: Optional[str]) -&gt; None:\n        \"\"\"Perform the placeholder substitutions using the template file.\n\n        Args:\n            key_val_file (str): The path of the file that contains the key-value pairs.\n            template_file (str): The path of the template file that contains the placeholders.\n            outfile (Optional[str]): The path of the output file to be created.\n        \"\"\"\n        if outfile is None:\n            outfile = self.outfile\n            if outfile is None:\n                raise ValueError(\"outfile must be specified\")\n\n        if template_file is None:\n            template_file = self.template_file\n            if template_file is None:\n                raise ValueError(\"template_file must be specified\")\n        else:\n            self.template_file = template_file\n\n        check_infile_status(template_file)\n        check_infile_status(key_val_file, \"yaml\")\n\n        check_outfile_status(outfile)\n        lookup: Dict[str, List[str]] = self._get_lookup(key_val_file)\n\n        # Some values will themselves have some placholder values\n        # that will need to be substituted with the placeholders that\n        # are keys.\n        for key in lookup:\n            for current_key, val in lookup.items():\n                if key == current_key:\n                    continue\n                if key in val:\n                    lookup[current_key] = val.replace(key, lookup[key])\n\n\n        with open(template_file, \"r\") as tf:\n            with open(outfile, \"w\") as of:\n                for line in tf:\n                    for key, value in lookup.items():\n                        if key not in self._found_keys_lookup:\n                            self._found_keys_lookup[key] = 0\n                        if key in line:\n                            line = line.replace(key, value)\n                            self._found_keys_lookup[key] += 1\n                            self._found_keys_ctr += 1\n\n                    of.write(line)\n\n        console.print(f\"Created output file '{outfile}'\")\n        logging.info(f\"Created output file '{outfile}'\")\n\n        self._report_substitution_status(lookup)\n\n    def _report_substitution_status(self, lookup: Dict[str, int]) -&gt; None:\n        \"\"\"Print the found keys lookup.\n\n        Args:\n            lookup (Dict[str, int]): The lookup of found keys.\n        \"\"\"\n        if self._found_keys_ctr &gt; 0:\n            if self.verbose:\n                console.print(\"Found keys lookup:\")\n            logging.info(\"Found keys lookup:\")\n\n            for key, count in self._found_keys_lookup.items():\n                if self.verbose:\n                    console.print(f\"Found placeholder '{key}' on '{count}' lines in template file '{self.template_file}'\")\n                logging.info(f\"Found placeholder '{key}' on '{count}' lines in template file '{self.template_file}'\")\n        else:\n            console.print(f\"None of the placeholders were substituted in template file '{self.template_file}' given the key-value pairs defined in file '{self.key_val_file}'\")\n            logging.warning(f\"None of the placeholders were substituted in template file '{self.template_file}' given the key-value pairs defined in file '{self.key_val_file}'\")\n\n        for key in lookup:\n            if key not in self._found_keys_lookup:\n                error_console.print(f\"Did not find placeholder '{key}' in template file '{self.template_file}'\")\n                logging.warning(f\"Did not find placeholder '{key}' in template file '{self.template_file}'\")\n\n\n    def insert_lines(\n        self,\n        key_val_file: str,\n        template_file: str,\n        outfile: Optional[str]) -&gt; None:\n        \"\"\"Perform the placeholder substitutions using the template file.\n\n        Args:\n            key_val_file (str): The path of the file that contains the key-value pairs.\n            template_file (str): The path of the template file that contains the placeholders.\n            outfile (Optional[str]): The path of the output file to be created.\n        \"\"\"\n        if outfile is None:\n            outfile = self.outfile\n            if outfile is None:\n                raise ValueError(\"outfile must be specified\")\n\n        check_infile_status(template_file)\n        check_infile_status(key_val_file, \"yaml\")\n\n        check_outfile_status(outfile)\n\n        lookup: Dict[str, List[str]] = self._get_lookup(key_val_file)\n\n        with open(self.template_file, \"r\") as template_file:\n            with open(outfile, \"w\") as output_file:\n                for line in template_file:\n                    for key, outlines in lookup.items():\n                        if key in line:\n                            self._found_keys_lookup[key] += 1\n                            self._found_keys_ctr += 1\n                            for outline in outlines:\n                                output_file.write(f\"{outline}\\n\")\n\n                    output_file.write(line)\n\n        console.print(f\"Created output file '{outfile}'\")\n        logging.info(f\"Created output file '{outfile}'\")\n\n        self._report_substitution_status(lookup)\n</code></pre>"},{"location":"manager/#simple_template_toolkit.manager.Manager.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Constructor for Manager.</p> Source code in <code>simple_template_toolkit/manager.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Constructor for Manager.\"\"\"\n    self.template_file = kwargs.get(\"template_file\", None)\n    self.key_val_file = kwargs.get(\"key_val_file\", None)\n    self.outdir = kwargs.get(\"outdir\", None)\n    self.outfile = kwargs.get(\"outfile\", None)\n    self.verbose = kwargs.get(\"verbose\", constants.DEFAULT_VERBOSE)\n\n    self._found_keys_lookup = {}\n    self._found_keys_ctr = 0\n\n    logging.info(f\"Instantiated Manager in file '{os.path.abspath(__file__)}'\")\n</code></pre>"},{"location":"manager/#simple_template_toolkit.manager.Manager._get_lookup","title":"<code>_get_lookup(key_val_file)</code>","text":"<p>Derive the lookup from the key-value pairs YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>key_val_file</code> <code>str</code> <p>The key-value pairs YAML file.</p> required <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: The lookup.</p> Source code in <code>simple_template_toolkit/manager.py</code> <pre><code>def _get_lookup(self, key_val_file: str) -&gt; Dict[str, str]:\n    \"\"\"Derive the lookup from the key-value pairs YAML file.\n\n    Args:\n        key_val_file (str): The key-value pairs YAML file.\n\n    Returns:\n        Dict[str, str]: The lookup.\n    \"\"\"\n    logging.info(f\"Will load contents of key-value file '{key_val_file}'\")\n    lookup = yaml.safe_load(Path(key_val_file).read_text())\n    return lookup\n</code></pre>"},{"location":"manager/#simple_template_toolkit.manager.Manager._report_substitution_status","title":"<code>_report_substitution_status(lookup)</code>","text":"<p>Print the found keys lookup.</p> <p>Parameters:</p> Name Type Description Default <code>lookup</code> <code>Dict[str, int]</code> <p>The lookup of found keys.</p> required Source code in <code>simple_template_toolkit/manager.py</code> <pre><code>def _report_substitution_status(self, lookup: Dict[str, int]) -&gt; None:\n    \"\"\"Print the found keys lookup.\n\n    Args:\n        lookup (Dict[str, int]): The lookup of found keys.\n    \"\"\"\n    if self._found_keys_ctr &gt; 0:\n        if self.verbose:\n            console.print(\"Found keys lookup:\")\n        logging.info(\"Found keys lookup:\")\n\n        for key, count in self._found_keys_lookup.items():\n            if self.verbose:\n                console.print(f\"Found placeholder '{key}' on '{count}' lines in template file '{self.template_file}'\")\n            logging.info(f\"Found placeholder '{key}' on '{count}' lines in template file '{self.template_file}'\")\n    else:\n        console.print(f\"None of the placeholders were substituted in template file '{self.template_file}' given the key-value pairs defined in file '{self.key_val_file}'\")\n        logging.warning(f\"None of the placeholders were substituted in template file '{self.template_file}' given the key-value pairs defined in file '{self.key_val_file}'\")\n\n    for key in lookup:\n        if key not in self._found_keys_lookup:\n            error_console.print(f\"Did not find placeholder '{key}' in template file '{self.template_file}'\")\n            logging.warning(f\"Did not find placeholder '{key}' in template file '{self.template_file}'\")\n</code></pre>"},{"location":"manager/#simple_template_toolkit.manager.Manager.insert_lines","title":"<code>insert_lines(key_val_file, template_file, outfile)</code>","text":"<p>Perform the placeholder substitutions using the template file.</p> <p>Parameters:</p> Name Type Description Default <code>key_val_file</code> <code>str</code> <p>The path of the file that contains the key-value pairs.</p> required <code>template_file</code> <code>str</code> <p>The path of the template file that contains the placeholders.</p> required <code>outfile</code> <code>Optional[str]</code> <p>The path of the output file to be created.</p> required Source code in <code>simple_template_toolkit/manager.py</code> <pre><code>def insert_lines(\n    self,\n    key_val_file: str,\n    template_file: str,\n    outfile: Optional[str]) -&gt; None:\n    \"\"\"Perform the placeholder substitutions using the template file.\n\n    Args:\n        key_val_file (str): The path of the file that contains the key-value pairs.\n        template_file (str): The path of the template file that contains the placeholders.\n        outfile (Optional[str]): The path of the output file to be created.\n    \"\"\"\n    if outfile is None:\n        outfile = self.outfile\n        if outfile is None:\n            raise ValueError(\"outfile must be specified\")\n\n    check_infile_status(template_file)\n    check_infile_status(key_val_file, \"yaml\")\n\n    check_outfile_status(outfile)\n\n    lookup: Dict[str, List[str]] = self._get_lookup(key_val_file)\n\n    with open(self.template_file, \"r\") as template_file:\n        with open(outfile, \"w\") as output_file:\n            for line in template_file:\n                for key, outlines in lookup.items():\n                    if key in line:\n                        self._found_keys_lookup[key] += 1\n                        self._found_keys_ctr += 1\n                        for outline in outlines:\n                            output_file.write(f\"{outline}\\n\")\n\n                output_file.write(line)\n\n    console.print(f\"Created output file '{outfile}'\")\n    logging.info(f\"Created output file '{outfile}'\")\n\n    self._report_substitution_status(lookup)\n</code></pre>"},{"location":"manager/#simple_template_toolkit.manager.Manager.make_substitutions","title":"<code>make_substitutions(key_val_file, template_file, outfile)</code>","text":"<p>Perform the placeholder substitutions using the template file.</p> <p>Parameters:</p> Name Type Description Default <code>key_val_file</code> <code>str</code> <p>The path of the file that contains the key-value pairs.</p> required <code>template_file</code> <code>str</code> <p>The path of the template file that contains the placeholders.</p> required <code>outfile</code> <code>Optional[str]</code> <p>The path of the output file to be created.</p> required Source code in <code>simple_template_toolkit/manager.py</code> <pre><code>def make_substitutions(self, key_val_file: Optional[str], template_file: Optional[str], outfile: Optional[str]) -&gt; None:\n    \"\"\"Perform the placeholder substitutions using the template file.\n\n    Args:\n        key_val_file (str): The path of the file that contains the key-value pairs.\n        template_file (str): The path of the template file that contains the placeholders.\n        outfile (Optional[str]): The path of the output file to be created.\n    \"\"\"\n    if outfile is None:\n        outfile = self.outfile\n        if outfile is None:\n            raise ValueError(\"outfile must be specified\")\n\n    if template_file is None:\n        template_file = self.template_file\n        if template_file is None:\n            raise ValueError(\"template_file must be specified\")\n    else:\n        self.template_file = template_file\n\n    check_infile_status(template_file)\n    check_infile_status(key_val_file, \"yaml\")\n\n    check_outfile_status(outfile)\n    lookup: Dict[str, List[str]] = self._get_lookup(key_val_file)\n\n    # Some values will themselves have some placholder values\n    # that will need to be substituted with the placeholders that\n    # are keys.\n    for key in lookup:\n        for current_key, val in lookup.items():\n            if key == current_key:\n                continue\n            if key in val:\n                lookup[current_key] = val.replace(key, lookup[key])\n\n\n    with open(template_file, \"r\") as tf:\n        with open(outfile, \"w\") as of:\n            for line in tf:\n                for key, value in lookup.items():\n                    if key not in self._found_keys_lookup:\n                        self._found_keys_lookup[key] = 0\n                    if key in line:\n                        line = line.replace(key, value)\n                        self._found_keys_lookup[key] += 1\n                        self._found_keys_ctr += 1\n\n                of.write(line)\n\n    console.print(f\"Created output file '{outfile}'\")\n    logging.info(f\"Created output file '{outfile}'\")\n\n    self._report_substitution_status(lookup)\n</code></pre>"}]}